<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: walletunlocker.proto

namespace Lnrpc;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Generated from protobuf message <code>lnrpc.InitWalletRequest</code>
 */
class InitWalletRequest extends \Google\Protobuf\Internal\Message
{
    /**
     *wallet_password is the passphrase that should be used to encrypt the
     *wallet. This MUST be at least 8 chars in length. After creation, this
     *password is required to unlock the daemon. When using REST, this field
     *must be encoded as base64.
     *
     * Generated from protobuf field <code>bytes wallet_password = 1;</code>
     */
    protected $wallet_password = '';
    /**
     *cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
     *cipher seed obtained by the user. This may have been generated by the
     *GenSeed method, or be an existing seed.
     *
     * Generated from protobuf field <code>repeated string cipher_seed_mnemonic = 2;</code>
     */
    private $cipher_seed_mnemonic;
    /**
     *aezeed_passphrase is an optional user provided passphrase that will be used
     *to encrypt the generated aezeed cipher seed. When using REST, this field
     *must be encoded as base64.
     *
     * Generated from protobuf field <code>bytes aezeed_passphrase = 3;</code>
     */
    protected $aezeed_passphrase = '';
    /**
     *recovery_window is an optional argument specifying the address lookahead
     *when restoring a wallet seed. The recovery window applies to each
     *individual branch of the BIP44 derivation paths. Supplying a recovery
     *window of zero indicates that no addresses should be recovered, such after
     *the first initialization of the wallet.
     *
     * Generated from protobuf field <code>int32 recovery_window = 4;</code>
     */
    protected $recovery_window = 0;
    /**
     *channel_backups is an optional argument that allows clients to recover the
     *settled funds within a set of channels. This should be populated if the
     *user was unable to close out all channels and sweep funds before partial or
     *total data loss occurred. If specified, then after on-chain recovery of
     *funds, lnd begin to carry out the data loss recovery protocol in order to
     *recover the funds in each channel from a remote force closed transaction.
     *
     * Generated from protobuf field <code>.lnrpc.ChanBackupSnapshot channel_backups = 5;</code>
     */
    protected $channel_backups = null;
    /**
     *stateless_init is an optional argument instructing the daemon NOT to create
     *any *.macaroon files in its filesystem. If this parameter is set, then the
     *admin macaroon returned in the response MUST be stored by the caller of the
     *RPC as otherwise all access to the daemon will be lost!
     *
     * Generated from protobuf field <code>bool stateless_init = 6;</code>
     */
    protected $stateless_init = false;
    /**
     *extended_master_key is an alternative to specifying cipher_seed_mnemonic and
     *aezeed_passphrase. Instead of deriving the master root key from the entropy
     *of an aezeed cipher seed, the given extended master root key is used
     *directly as the wallet's master key. This allows users to import/use a
     *master key from another wallet. When doing so, lnd still uses its default
     *SegWit only (BIP49/84) derivation paths and funds from custom/non-default
     *derivation paths will not automatically appear in the on-chain wallet. Using
     *an 'xprv' instead of an aezeed also has the disadvantage that the wallet's
     *birthday is not known as that is an information that's only encoded in the
     *aezeed, not the xprv. Therefore a birthday needs to be specified in
     *extended_master_key_birthday_timestamp or a "safe" default value will be
     *used.
     *
     * Generated from protobuf field <code>string extended_master_key = 7;</code>
     */
    protected $extended_master_key = '';
    /**
     *extended_master_key_birthday_timestamp is the optional unix timestamp in
     *seconds to use as the wallet's birthday when using an extended master key
     *to restore the wallet. lnd will only start scanning for funds in blocks that
     *are after the birthday which can speed up the process significantly. If the
     *birthday is not known, this should be left at its default value of 0 in
     *which case lnd will start scanning from the first SegWit block (481824 on
     *mainnet).
     *
     * Generated from protobuf field <code>uint64 extended_master_key_birthday_timestamp = 8;</code>
     */
    protected $extended_master_key_birthday_timestamp = 0;
    /**
     *watch_only is the third option of initializing a wallet: by importing
     *account xpubs only and therefore creating a watch-only wallet that does not
     *contain any private keys. That means the wallet won't be able to sign for
     *any of the keys and _needs_ to be run with a remote signer that has the
     *corresponding private keys and can serve signing RPC requests.
     *
     * Generated from protobuf field <code>.lnrpc.WatchOnly watch_only = 9;</code>
     */
    protected $watch_only = null;
    /**
     *macaroon_root_key is an optional 32 byte macaroon root key that can be
     *provided when initializing the wallet rather than letting lnd generate one
     *on its own.
     *
     * Generated from protobuf field <code>bytes macaroon_root_key = 10;</code>
     */
    protected $macaroon_root_key = '';

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type string $wallet_password
     *          wallet_password is the passphrase that should be used to encrypt the
     *          wallet. This MUST be at least 8 chars in length. After creation, this
     *          password is required to unlock the daemon. When using REST, this field
     *          must be encoded as base64.
     *     @type array<string>|\Google\Protobuf\Internal\RepeatedField $cipher_seed_mnemonic
     *          cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
     *          cipher seed obtained by the user. This may have been generated by the
     *          GenSeed method, or be an existing seed.
     *     @type string $aezeed_passphrase
     *          aezeed_passphrase is an optional user provided passphrase that will be used
     *          to encrypt the generated aezeed cipher seed. When using REST, this field
     *          must be encoded as base64.
     *     @type int $recovery_window
     *          recovery_window is an optional argument specifying the address lookahead
     *          when restoring a wallet seed. The recovery window applies to each
     *          individual branch of the BIP44 derivation paths. Supplying a recovery
     *          window of zero indicates that no addresses should be recovered, such after
     *          the first initialization of the wallet.
     *     @type \Lnrpc\ChanBackupSnapshot $channel_backups
     *          channel_backups is an optional argument that allows clients to recover the
     *          settled funds within a set of channels. This should be populated if the
     *          user was unable to close out all channels and sweep funds before partial or
     *          total data loss occurred. If specified, then after on-chain recovery of
     *          funds, lnd begin to carry out the data loss recovery protocol in order to
     *          recover the funds in each channel from a remote force closed transaction.
     *     @type bool $stateless_init
     *          stateless_init is an optional argument instructing the daemon NOT to create
     *          any *.macaroon files in its filesystem. If this parameter is set, then the
     *          admin macaroon returned in the response MUST be stored by the caller of the
     *          RPC as otherwise all access to the daemon will be lost!
     *     @type string $extended_master_key
     *          extended_master_key is an alternative to specifying cipher_seed_mnemonic and
     *          aezeed_passphrase. Instead of deriving the master root key from the entropy
     *          of an aezeed cipher seed, the given extended master root key is used
     *          directly as the wallet's master key. This allows users to import/use a
     *          master key from another wallet. When doing so, lnd still uses its default
     *          SegWit only (BIP49/84) derivation paths and funds from custom/non-default
     *          derivation paths will not automatically appear in the on-chain wallet. Using
     *          an 'xprv' instead of an aezeed also has the disadvantage that the wallet's
     *          birthday is not known as that is an information that's only encoded in the
     *          aezeed, not the xprv. Therefore a birthday needs to be specified in
     *          extended_master_key_birthday_timestamp or a "safe" default value will be
     *          used.
     *     @type int|string $extended_master_key_birthday_timestamp
     *          extended_master_key_birthday_timestamp is the optional unix timestamp in
     *          seconds to use as the wallet's birthday when using an extended master key
     *          to restore the wallet. lnd will only start scanning for funds in blocks that
     *          are after the birthday which can speed up the process significantly. If the
     *          birthday is not known, this should be left at its default value of 0 in
     *          which case lnd will start scanning from the first SegWit block (481824 on
     *          mainnet).
     *     @type \Lnrpc\WatchOnly $watch_only
     *          watch_only is the third option of initializing a wallet: by importing
     *          account xpubs only and therefore creating a watch-only wallet that does not
     *          contain any private keys. That means the wallet won't be able to sign for
     *          any of the keys and _needs_ to be run with a remote signer that has the
     *          corresponding private keys and can serve signing RPC requests.
     *     @type string $macaroon_root_key
     *          macaroon_root_key is an optional 32 byte macaroon root key that can be
     *          provided when initializing the wallet rather than letting lnd generate one
     *          on its own.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Walletunlocker::initOnce();
        parent::__construct($data);
    }

    /**
     *wallet_password is the passphrase that should be used to encrypt the
     *wallet. This MUST be at least 8 chars in length. After creation, this
     *password is required to unlock the daemon. When using REST, this field
     *must be encoded as base64.
     *
     * Generated from protobuf field <code>bytes wallet_password = 1;</code>
     * @return string
     */
    public function getWalletPassword()
    {
        return $this->wallet_password;
    }

    /**
     *wallet_password is the passphrase that should be used to encrypt the
     *wallet. This MUST be at least 8 chars in length. After creation, this
     *password is required to unlock the daemon. When using REST, this field
     *must be encoded as base64.
     *
     * Generated from protobuf field <code>bytes wallet_password = 1;</code>
     * @param string $var
     * @return $this
     */
    public function setWalletPassword($var)
    {
        GPBUtil::checkString($var, False);
        $this->wallet_password = $var;

        return $this;
    }

    /**
     *cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
     *cipher seed obtained by the user. This may have been generated by the
     *GenSeed method, or be an existing seed.
     *
     * Generated from protobuf field <code>repeated string cipher_seed_mnemonic = 2;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getCipherSeedMnemonic()
    {
        return $this->cipher_seed_mnemonic;
    }

    /**
     *cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
     *cipher seed obtained by the user. This may have been generated by the
     *GenSeed method, or be an existing seed.
     *
     * Generated from protobuf field <code>repeated string cipher_seed_mnemonic = 2;</code>
     * @param array<string>|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setCipherSeedMnemonic($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::STRING);
        $this->cipher_seed_mnemonic = $arr;

        return $this;
    }

    /**
     *aezeed_passphrase is an optional user provided passphrase that will be used
     *to encrypt the generated aezeed cipher seed. When using REST, this field
     *must be encoded as base64.
     *
     * Generated from protobuf field <code>bytes aezeed_passphrase = 3;</code>
     * @return string
     */
    public function getAezeedPassphrase()
    {
        return $this->aezeed_passphrase;
    }

    /**
     *aezeed_passphrase is an optional user provided passphrase that will be used
     *to encrypt the generated aezeed cipher seed. When using REST, this field
     *must be encoded as base64.
     *
     * Generated from protobuf field <code>bytes aezeed_passphrase = 3;</code>
     * @param string $var
     * @return $this
     */
    public function setAezeedPassphrase($var)
    {
        GPBUtil::checkString($var, False);
        $this->aezeed_passphrase = $var;

        return $this;
    }

    /**
     *recovery_window is an optional argument specifying the address lookahead
     *when restoring a wallet seed. The recovery window applies to each
     *individual branch of the BIP44 derivation paths. Supplying a recovery
     *window of zero indicates that no addresses should be recovered, such after
     *the first initialization of the wallet.
     *
     * Generated from protobuf field <code>int32 recovery_window = 4;</code>
     * @return int
     */
    public function getRecoveryWindow()
    {
        return $this->recovery_window;
    }

    /**
     *recovery_window is an optional argument specifying the address lookahead
     *when restoring a wallet seed. The recovery window applies to each
     *individual branch of the BIP44 derivation paths. Supplying a recovery
     *window of zero indicates that no addresses should be recovered, such after
     *the first initialization of the wallet.
     *
     * Generated from protobuf field <code>int32 recovery_window = 4;</code>
     * @param int $var
     * @return $this
     */
    public function setRecoveryWindow($var)
    {
        GPBUtil::checkInt32($var);
        $this->recovery_window = $var;

        return $this;
    }

    /**
     *channel_backups is an optional argument that allows clients to recover the
     *settled funds within a set of channels. This should be populated if the
     *user was unable to close out all channels and sweep funds before partial or
     *total data loss occurred. If specified, then after on-chain recovery of
     *funds, lnd begin to carry out the data loss recovery protocol in order to
     *recover the funds in each channel from a remote force closed transaction.
     *
     * Generated from protobuf field <code>.lnrpc.ChanBackupSnapshot channel_backups = 5;</code>
     * @return \Lnrpc\ChanBackupSnapshot|null
     */
    public function getChannelBackups()
    {
        return $this->channel_backups;
    }

    public function hasChannelBackups()
    {
        return isset($this->channel_backups);
    }

    public function clearChannelBackups()
    {
        unset($this->channel_backups);
    }

    /**
     *channel_backups is an optional argument that allows clients to recover the
     *settled funds within a set of channels. This should be populated if the
     *user was unable to close out all channels and sweep funds before partial or
     *total data loss occurred. If specified, then after on-chain recovery of
     *funds, lnd begin to carry out the data loss recovery protocol in order to
     *recover the funds in each channel from a remote force closed transaction.
     *
     * Generated from protobuf field <code>.lnrpc.ChanBackupSnapshot channel_backups = 5;</code>
     * @param \Lnrpc\ChanBackupSnapshot $var
     * @return $this
     */
    public function setChannelBackups($var)
    {
        GPBUtil::checkMessage($var, \Lnrpc\ChanBackupSnapshot::class);
        $this->channel_backups = $var;

        return $this;
    }

    /**
     *stateless_init is an optional argument instructing the daemon NOT to create
     *any *.macaroon files in its filesystem. If this parameter is set, then the
     *admin macaroon returned in the response MUST be stored by the caller of the
     *RPC as otherwise all access to the daemon will be lost!
     *
     * Generated from protobuf field <code>bool stateless_init = 6;</code>
     * @return bool
     */
    public function getStatelessInit()
    {
        return $this->stateless_init;
    }

    /**
     *stateless_init is an optional argument instructing the daemon NOT to create
     *any *.macaroon files in its filesystem. If this parameter is set, then the
     *admin macaroon returned in the response MUST be stored by the caller of the
     *RPC as otherwise all access to the daemon will be lost!
     *
     * Generated from protobuf field <code>bool stateless_init = 6;</code>
     * @param bool $var
     * @return $this
     */
    public function setStatelessInit($var)
    {
        GPBUtil::checkBool($var);
        $this->stateless_init = $var;

        return $this;
    }

    /**
     *extended_master_key is an alternative to specifying cipher_seed_mnemonic and
     *aezeed_passphrase. Instead of deriving the master root key from the entropy
     *of an aezeed cipher seed, the given extended master root key is used
     *directly as the wallet's master key. This allows users to import/use a
     *master key from another wallet. When doing so, lnd still uses its default
     *SegWit only (BIP49/84) derivation paths and funds from custom/non-default
     *derivation paths will not automatically appear in the on-chain wallet. Using
     *an 'xprv' instead of an aezeed also has the disadvantage that the wallet's
     *birthday is not known as that is an information that's only encoded in the
     *aezeed, not the xprv. Therefore a birthday needs to be specified in
     *extended_master_key_birthday_timestamp or a "safe" default value will be
     *used.
     *
     * Generated from protobuf field <code>string extended_master_key = 7;</code>
     * @return string
     */
    public function getExtendedMasterKey()
    {
        return $this->extended_master_key;
    }

    /**
     *extended_master_key is an alternative to specifying cipher_seed_mnemonic and
     *aezeed_passphrase. Instead of deriving the master root key from the entropy
     *of an aezeed cipher seed, the given extended master root key is used
     *directly as the wallet's master key. This allows users to import/use a
     *master key from another wallet. When doing so, lnd still uses its default
     *SegWit only (BIP49/84) derivation paths and funds from custom/non-default
     *derivation paths will not automatically appear in the on-chain wallet. Using
     *an 'xprv' instead of an aezeed also has the disadvantage that the wallet's
     *birthday is not known as that is an information that's only encoded in the
     *aezeed, not the xprv. Therefore a birthday needs to be specified in
     *extended_master_key_birthday_timestamp or a "safe" default value will be
     *used.
     *
     * Generated from protobuf field <code>string extended_master_key = 7;</code>
     * @param string $var
     * @return $this
     */
    public function setExtendedMasterKey($var)
    {
        GPBUtil::checkString($var, True);
        $this->extended_master_key = $var;

        return $this;
    }

    /**
     *extended_master_key_birthday_timestamp is the optional unix timestamp in
     *seconds to use as the wallet's birthday when using an extended master key
     *to restore the wallet. lnd will only start scanning for funds in blocks that
     *are after the birthday which can speed up the process significantly. If the
     *birthday is not known, this should be left at its default value of 0 in
     *which case lnd will start scanning from the first SegWit block (481824 on
     *mainnet).
     *
     * Generated from protobuf field <code>uint64 extended_master_key_birthday_timestamp = 8;</code>
     * @return int|string
     */
    public function getExtendedMasterKeyBirthdayTimestamp()
    {
        return $this->extended_master_key_birthday_timestamp;
    }

    /**
     *extended_master_key_birthday_timestamp is the optional unix timestamp in
     *seconds to use as the wallet's birthday when using an extended master key
     *to restore the wallet. lnd will only start scanning for funds in blocks that
     *are after the birthday which can speed up the process significantly. If the
     *birthday is not known, this should be left at its default value of 0 in
     *which case lnd will start scanning from the first SegWit block (481824 on
     *mainnet).
     *
     * Generated from protobuf field <code>uint64 extended_master_key_birthday_timestamp = 8;</code>
     * @param int|string $var
     * @return $this
     */
    public function setExtendedMasterKeyBirthdayTimestamp($var)
    {
        GPBUtil::checkUint64($var);
        $this->extended_master_key_birthday_timestamp = $var;

        return $this;
    }

    /**
     *watch_only is the third option of initializing a wallet: by importing
     *account xpubs only and therefore creating a watch-only wallet that does not
     *contain any private keys. That means the wallet won't be able to sign for
     *any of the keys and _needs_ to be run with a remote signer that has the
     *corresponding private keys and can serve signing RPC requests.
     *
     * Generated from protobuf field <code>.lnrpc.WatchOnly watch_only = 9;</code>
     * @return \Lnrpc\WatchOnly|null
     */
    public function getWatchOnly()
    {
        return $this->watch_only;
    }

    public function hasWatchOnly()
    {
        return isset($this->watch_only);
    }

    public function clearWatchOnly()
    {
        unset($this->watch_only);
    }

    /**
     *watch_only is the third option of initializing a wallet: by importing
     *account xpubs only and therefore creating a watch-only wallet that does not
     *contain any private keys. That means the wallet won't be able to sign for
     *any of the keys and _needs_ to be run with a remote signer that has the
     *corresponding private keys and can serve signing RPC requests.
     *
     * Generated from protobuf field <code>.lnrpc.WatchOnly watch_only = 9;</code>
     * @param \Lnrpc\WatchOnly $var
     * @return $this
     */
    public function setWatchOnly($var)
    {
        GPBUtil::checkMessage($var, \Lnrpc\WatchOnly::class);
        $this->watch_only = $var;

        return $this;
    }

    /**
     *macaroon_root_key is an optional 32 byte macaroon root key that can be
     *provided when initializing the wallet rather than letting lnd generate one
     *on its own.
     *
     * Generated from protobuf field <code>bytes macaroon_root_key = 10;</code>
     * @return string
     */
    public function getMacaroonRootKey()
    {
        return $this->macaroon_root_key;
    }

    /**
     *macaroon_root_key is an optional 32 byte macaroon root key that can be
     *provided when initializing the wallet rather than letting lnd generate one
     *on its own.
     *
     * Generated from protobuf field <code>bytes macaroon_root_key = 10;</code>
     * @param string $var
     * @return $this
     */
    public function setMacaroonRootKey($var)
    {
        GPBUtil::checkString($var, False);
        $this->macaroon_root_key = $var;

        return $this;
    }

}

