<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: lightning.proto

namespace Lnrpc;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Generated from protobuf message <code>lnrpc.RPCMiddlewareRequest</code>
 */
class RPCMiddlewareRequest extends \Google\Protobuf\Internal\Message
{
    /**
     *The unique ID of the intercepted original gRPC request. Useful for mapping
     *request to response when implementing full duplex message interception. For
     *streaming requests, this will be the same ID for all incoming and outgoing
     *middleware intercept messages of the _same_ stream.
     *
     * Generated from protobuf field <code>uint64 request_id = 1;</code>
     */
    protected $request_id = 0;
    /**
     *The raw bytes of the complete macaroon as sent by the gRPC client in the
     *original request. This might be empty for a request that doesn't require
     *macaroons such as the wallet unlocker RPCs.
     *
     * Generated from protobuf field <code>bytes raw_macaroon = 2;</code>
     */
    protected $raw_macaroon = '';
    /**
     *The parsed condition of the macaroon's custom caveat for convenient access.
     *This field only contains the value of the custom caveat that the handling
     *middleware has registered itself for. The condition _must_ be validated for
     *messages of intercept_type stream_auth and request!
     *
     * Generated from protobuf field <code>string custom_caveat_condition = 3;</code>
     */
    protected $custom_caveat_condition = '';
    /**
     *The unique message ID of this middleware intercept message. There can be
     *multiple middleware intercept messages per single gRPC request (one for the
     *incoming request and one for the outgoing response) or gRPC stream (one for
     *each incoming message and one for each outgoing response). This message ID
     *must be referenced when responding (accepting/rejecting/modifying) to an
     *intercept message.
     *
     * Generated from protobuf field <code>uint64 msg_id = 7;</code>
     */
    protected $msg_id = 0;
    protected $intercept_type;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type int|string $request_id
     *          The unique ID of the intercepted original gRPC request. Useful for mapping
     *          request to response when implementing full duplex message interception. For
     *          streaming requests, this will be the same ID for all incoming and outgoing
     *          middleware intercept messages of the _same_ stream.
     *     @type string $raw_macaroon
     *          The raw bytes of the complete macaroon as sent by the gRPC client in the
     *          original request. This might be empty for a request that doesn't require
     *          macaroons such as the wallet unlocker RPCs.
     *     @type string $custom_caveat_condition
     *          The parsed condition of the macaroon's custom caveat for convenient access.
     *          This field only contains the value of the custom caveat that the handling
     *          middleware has registered itself for. The condition _must_ be validated for
     *          messages of intercept_type stream_auth and request!
     *     @type \Lnrpc\StreamAuth $stream_auth
     *          Intercept stream authentication: each new streaming RPC call that is
     *          initiated against lnd and contains the middleware's custom macaroon
     *          caveat can be approved or denied based upon the macaroon in the stream
     *          header. This message will only be sent for streaming RPCs, unary RPCs
     *          must handle the macaroon authentication in the request interception to
     *          avoid an additional message round trip between lnd and the middleware.
     *     @type \Lnrpc\RPCMessage $request
     *          Intercept incoming gRPC client request message: all incoming messages,
     *          both on streaming and unary RPCs, are forwarded to the middleware for
     *          inspection. For unary RPC messages the middleware is also expected to
     *          validate the custom macaroon caveat of the request.
     *     @type \Lnrpc\RPCMessage $response
     *          Intercept outgoing gRPC response message: all outgoing messages, both on
     *          streaming and unary RPCs, are forwarded to the middleware for inspection
     *          and amendment. The response in this message is the original response as
     *          it was generated by the main RPC server. It can either be accepted
     *          (=forwarded to the client), replaced/overwritten with a new message of
     *          the same type, or replaced by an error message.
     *     @type bool $reg_complete
     *          This is used to indicate to the client that the server has successfully
     *          registered the interceptor. This is only used in the very first message
     *          that the server sends to the client after the client sends the server
     *          the middleware registration message.
     *     @type int|string $msg_id
     *          The unique message ID of this middleware intercept message. There can be
     *          multiple middleware intercept messages per single gRPC request (one for the
     *          incoming request and one for the outgoing response) or gRPC stream (one for
     *          each incoming message and one for each outgoing response). This message ID
     *          must be referenced when responding (accepting/rejecting/modifying) to an
     *          intercept message.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Lightning::initOnce();
        parent::__construct($data);
    }

    /**
     *The unique ID of the intercepted original gRPC request. Useful for mapping
     *request to response when implementing full duplex message interception. For
     *streaming requests, this will be the same ID for all incoming and outgoing
     *middleware intercept messages of the _same_ stream.
     *
     * Generated from protobuf field <code>uint64 request_id = 1;</code>
     * @return int|string
     */
    public function getRequestId()
    {
        return $this->request_id;
    }

    /**
     *The unique ID of the intercepted original gRPC request. Useful for mapping
     *request to response when implementing full duplex message interception. For
     *streaming requests, this will be the same ID for all incoming and outgoing
     *middleware intercept messages of the _same_ stream.
     *
     * Generated from protobuf field <code>uint64 request_id = 1;</code>
     * @param int|string $var
     * @return $this
     */
    public function setRequestId($var)
    {
        GPBUtil::checkUint64($var);
        $this->request_id = $var;

        return $this;
    }

    /**
     *The raw bytes of the complete macaroon as sent by the gRPC client in the
     *original request. This might be empty for a request that doesn't require
     *macaroons such as the wallet unlocker RPCs.
     *
     * Generated from protobuf field <code>bytes raw_macaroon = 2;</code>
     * @return string
     */
    public function getRawMacaroon()
    {
        return $this->raw_macaroon;
    }

    /**
     *The raw bytes of the complete macaroon as sent by the gRPC client in the
     *original request. This might be empty for a request that doesn't require
     *macaroons such as the wallet unlocker RPCs.
     *
     * Generated from protobuf field <code>bytes raw_macaroon = 2;</code>
     * @param string $var
     * @return $this
     */
    public function setRawMacaroon($var)
    {
        GPBUtil::checkString($var, False);
        $this->raw_macaroon = $var;

        return $this;
    }

    /**
     *The parsed condition of the macaroon's custom caveat for convenient access.
     *This field only contains the value of the custom caveat that the handling
     *middleware has registered itself for. The condition _must_ be validated for
     *messages of intercept_type stream_auth and request!
     *
     * Generated from protobuf field <code>string custom_caveat_condition = 3;</code>
     * @return string
     */
    public function getCustomCaveatCondition()
    {
        return $this->custom_caveat_condition;
    }

    /**
     *The parsed condition of the macaroon's custom caveat for convenient access.
     *This field only contains the value of the custom caveat that the handling
     *middleware has registered itself for. The condition _must_ be validated for
     *messages of intercept_type stream_auth and request!
     *
     * Generated from protobuf field <code>string custom_caveat_condition = 3;</code>
     * @param string $var
     * @return $this
     */
    public function setCustomCaveatCondition($var)
    {
        GPBUtil::checkString($var, True);
        $this->custom_caveat_condition = $var;

        return $this;
    }

    /**
     *Intercept stream authentication: each new streaming RPC call that is
     *initiated against lnd and contains the middleware's custom macaroon
     *caveat can be approved or denied based upon the macaroon in the stream
     *header. This message will only be sent for streaming RPCs, unary RPCs
     *must handle the macaroon authentication in the request interception to
     *avoid an additional message round trip between lnd and the middleware.
     *
     * Generated from protobuf field <code>.lnrpc.StreamAuth stream_auth = 4;</code>
     * @return \Lnrpc\StreamAuth|null
     */
    public function getStreamAuth()
    {
        return $this->readOneof(4);
    }

    public function hasStreamAuth()
    {
        return $this->hasOneof(4);
    }

    /**
     *Intercept stream authentication: each new streaming RPC call that is
     *initiated against lnd and contains the middleware's custom macaroon
     *caveat can be approved or denied based upon the macaroon in the stream
     *header. This message will only be sent for streaming RPCs, unary RPCs
     *must handle the macaroon authentication in the request interception to
     *avoid an additional message round trip between lnd and the middleware.
     *
     * Generated from protobuf field <code>.lnrpc.StreamAuth stream_auth = 4;</code>
     * @param \Lnrpc\StreamAuth $var
     * @return $this
     */
    public function setStreamAuth($var)
    {
        GPBUtil::checkMessage($var, \Lnrpc\StreamAuth::class);
        $this->writeOneof(4, $var);

        return $this;
    }

    /**
     *Intercept incoming gRPC client request message: all incoming messages,
     *both on streaming and unary RPCs, are forwarded to the middleware for
     *inspection. For unary RPC messages the middleware is also expected to
     *validate the custom macaroon caveat of the request.
     *
     * Generated from protobuf field <code>.lnrpc.RPCMessage request = 5;</code>
     * @return \Lnrpc\RPCMessage|null
     */
    public function getRequest()
    {
        return $this->readOneof(5);
    }

    public function hasRequest()
    {
        return $this->hasOneof(5);
    }

    /**
     *Intercept incoming gRPC client request message: all incoming messages,
     *both on streaming and unary RPCs, are forwarded to the middleware for
     *inspection. For unary RPC messages the middleware is also expected to
     *validate the custom macaroon caveat of the request.
     *
     * Generated from protobuf field <code>.lnrpc.RPCMessage request = 5;</code>
     * @param \Lnrpc\RPCMessage $var
     * @return $this
     */
    public function setRequest($var)
    {
        GPBUtil::checkMessage($var, \Lnrpc\RPCMessage::class);
        $this->writeOneof(5, $var);

        return $this;
    }

    /**
     *Intercept outgoing gRPC response message: all outgoing messages, both on
     *streaming and unary RPCs, are forwarded to the middleware for inspection
     *and amendment. The response in this message is the original response as
     *it was generated by the main RPC server. It can either be accepted
     *(=forwarded to the client), replaced/overwritten with a new message of
     *the same type, or replaced by an error message.
     *
     * Generated from protobuf field <code>.lnrpc.RPCMessage response = 6;</code>
     * @return \Lnrpc\RPCMessage|null
     */
    public function getResponse()
    {
        return $this->readOneof(6);
    }

    public function hasResponse()
    {
        return $this->hasOneof(6);
    }

    /**
     *Intercept outgoing gRPC response message: all outgoing messages, both on
     *streaming and unary RPCs, are forwarded to the middleware for inspection
     *and amendment. The response in this message is the original response as
     *it was generated by the main RPC server. It can either be accepted
     *(=forwarded to the client), replaced/overwritten with a new message of
     *the same type, or replaced by an error message.
     *
     * Generated from protobuf field <code>.lnrpc.RPCMessage response = 6;</code>
     * @param \Lnrpc\RPCMessage $var
     * @return $this
     */
    public function setResponse($var)
    {
        GPBUtil::checkMessage($var, \Lnrpc\RPCMessage::class);
        $this->writeOneof(6, $var);

        return $this;
    }

    /**
     *This is used to indicate to the client that the server has successfully
     *registered the interceptor. This is only used in the very first message
     *that the server sends to the client after the client sends the server
     *the middleware registration message.
     *
     * Generated from protobuf field <code>bool reg_complete = 8;</code>
     * @return bool
     */
    public function getRegComplete()
    {
        return $this->readOneof(8);
    }

    public function hasRegComplete()
    {
        return $this->hasOneof(8);
    }

    /**
     *This is used to indicate to the client that the server has successfully
     *registered the interceptor. This is only used in the very first message
     *that the server sends to the client after the client sends the server
     *the middleware registration message.
     *
     * Generated from protobuf field <code>bool reg_complete = 8;</code>
     * @param bool $var
     * @return $this
     */
    public function setRegComplete($var)
    {
        GPBUtil::checkBool($var);
        $this->writeOneof(8, $var);

        return $this;
    }

    /**
     *The unique message ID of this middleware intercept message. There can be
     *multiple middleware intercept messages per single gRPC request (one for the
     *incoming request and one for the outgoing response) or gRPC stream (one for
     *each incoming message and one for each outgoing response). This message ID
     *must be referenced when responding (accepting/rejecting/modifying) to an
     *intercept message.
     *
     * Generated from protobuf field <code>uint64 msg_id = 7;</code>
     * @return int|string
     */
    public function getMsgId()
    {
        return $this->msg_id;
    }

    /**
     *The unique message ID of this middleware intercept message. There can be
     *multiple middleware intercept messages per single gRPC request (one for the
     *incoming request and one for the outgoing response) or gRPC stream (one for
     *each incoming message and one for each outgoing response). This message ID
     *must be referenced when responding (accepting/rejecting/modifying) to an
     *intercept message.
     *
     * Generated from protobuf field <code>uint64 msg_id = 7;</code>
     * @param int|string $var
     * @return $this
     */
    public function setMsgId($var)
    {
        GPBUtil::checkUint64($var);
        $this->msg_id = $var;

        return $this;
    }

    /**
     * @return string
     */
    public function getInterceptType()
    {
        return $this->whichOneof("intercept_type");
    }

}

