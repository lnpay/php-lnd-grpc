<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: lightning.proto

namespace Lnrpc;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Generated from protobuf message <code>lnrpc.ListPaymentsRequest</code>
 */
class ListPaymentsRequest extends \Google\Protobuf\Internal\Message
{
    /**
     *If true, then return payments that have not yet fully completed. This means
     *that pending payments, as well as failed payments will show up if this
     *field is set to true. This flag doesn't change the meaning of the indices,
     *which are tied to individual payments.
     *
     * Generated from protobuf field <code>bool include_incomplete = 1;</code>
     */
    protected $include_incomplete = false;
    /**
     *The index of a payment that will be used as either the start or end of a
     *query to determine which payments should be returned in the response. The
     *index_offset is exclusive. In the case of a zero index_offset, the query
     *will start with the oldest payment when paginating forwards, or will end
     *with the most recent payment when paginating backwards.
     *
     * Generated from protobuf field <code>uint64 index_offset = 2;</code>
     */
    protected $index_offset = 0;
    /**
     * The maximal number of payments returned in the response to this query.
     *
     * Generated from protobuf field <code>uint64 max_payments = 3;</code>
     */
    protected $max_payments = 0;
    /**
     *If set, the payments returned will result from seeking backwards from the
     *specified index offset. This can be used to paginate backwards. The order
     *of the returned payments is always oldest first (ascending index order).
     *
     * Generated from protobuf field <code>bool reversed = 4;</code>
     */
    protected $reversed = false;
    /**
     *If set, all payments (complete and incomplete, independent of the
     *max_payments parameter) will be counted. Note that setting this to true will
     *increase the run time of the call significantly on systems that have a lot
     *of payments, as all of them have to be iterated through to be counted.
     *
     * Generated from protobuf field <code>bool count_total_payments = 5;</code>
     */
    protected $count_total_payments = false;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type bool $include_incomplete
     *          If true, then return payments that have not yet fully completed. This means
     *          that pending payments, as well as failed payments will show up if this
     *          field is set to true. This flag doesn't change the meaning of the indices,
     *          which are tied to individual payments.
     *     @type int|string $index_offset
     *          The index of a payment that will be used as either the start or end of a
     *          query to determine which payments should be returned in the response. The
     *          index_offset is exclusive. In the case of a zero index_offset, the query
     *          will start with the oldest payment when paginating forwards, or will end
     *          with the most recent payment when paginating backwards.
     *     @type int|string $max_payments
     *           The maximal number of payments returned in the response to this query.
     *     @type bool $reversed
     *          If set, the payments returned will result from seeking backwards from the
     *          specified index offset. This can be used to paginate backwards. The order
     *          of the returned payments is always oldest first (ascending index order).
     *     @type bool $count_total_payments
     *          If set, all payments (complete and incomplete, independent of the
     *          max_payments parameter) will be counted. Note that setting this to true will
     *          increase the run time of the call significantly on systems that have a lot
     *          of payments, as all of them have to be iterated through to be counted.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Lightning::initOnce();
        parent::__construct($data);
    }

    /**
     *If true, then return payments that have not yet fully completed. This means
     *that pending payments, as well as failed payments will show up if this
     *field is set to true. This flag doesn't change the meaning of the indices,
     *which are tied to individual payments.
     *
     * Generated from protobuf field <code>bool include_incomplete = 1;</code>
     * @return bool
     */
    public function getIncludeIncomplete()
    {
        return $this->include_incomplete;
    }

    /**
     *If true, then return payments that have not yet fully completed. This means
     *that pending payments, as well as failed payments will show up if this
     *field is set to true. This flag doesn't change the meaning of the indices,
     *which are tied to individual payments.
     *
     * Generated from protobuf field <code>bool include_incomplete = 1;</code>
     * @param bool $var
     * @return $this
     */
    public function setIncludeIncomplete($var)
    {
        GPBUtil::checkBool($var);
        $this->include_incomplete = $var;

        return $this;
    }

    /**
     *The index of a payment that will be used as either the start or end of a
     *query to determine which payments should be returned in the response. The
     *index_offset is exclusive. In the case of a zero index_offset, the query
     *will start with the oldest payment when paginating forwards, or will end
     *with the most recent payment when paginating backwards.
     *
     * Generated from protobuf field <code>uint64 index_offset = 2;</code>
     * @return int|string
     */
    public function getIndexOffset()
    {
        return $this->index_offset;
    }

    /**
     *The index of a payment that will be used as either the start or end of a
     *query to determine which payments should be returned in the response. The
     *index_offset is exclusive. In the case of a zero index_offset, the query
     *will start with the oldest payment when paginating forwards, or will end
     *with the most recent payment when paginating backwards.
     *
     * Generated from protobuf field <code>uint64 index_offset = 2;</code>
     * @param int|string $var
     * @return $this
     */
    public function setIndexOffset($var)
    {
        GPBUtil::checkUint64($var);
        $this->index_offset = $var;

        return $this;
    }

    /**
     * The maximal number of payments returned in the response to this query.
     *
     * Generated from protobuf field <code>uint64 max_payments = 3;</code>
     * @return int|string
     */
    public function getMaxPayments()
    {
        return $this->max_payments;
    }

    /**
     * The maximal number of payments returned in the response to this query.
     *
     * Generated from protobuf field <code>uint64 max_payments = 3;</code>
     * @param int|string $var
     * @return $this
     */
    public function setMaxPayments($var)
    {
        GPBUtil::checkUint64($var);
        $this->max_payments = $var;

        return $this;
    }

    /**
     *If set, the payments returned will result from seeking backwards from the
     *specified index offset. This can be used to paginate backwards. The order
     *of the returned payments is always oldest first (ascending index order).
     *
     * Generated from protobuf field <code>bool reversed = 4;</code>
     * @return bool
     */
    public function getReversed()
    {
        return $this->reversed;
    }

    /**
     *If set, the payments returned will result from seeking backwards from the
     *specified index offset. This can be used to paginate backwards. The order
     *of the returned payments is always oldest first (ascending index order).
     *
     * Generated from protobuf field <code>bool reversed = 4;</code>
     * @param bool $var
     * @return $this
     */
    public function setReversed($var)
    {
        GPBUtil::checkBool($var);
        $this->reversed = $var;

        return $this;
    }

    /**
     *If set, all payments (complete and incomplete, independent of the
     *max_payments parameter) will be counted. Note that setting this to true will
     *increase the run time of the call significantly on systems that have a lot
     *of payments, as all of them have to be iterated through to be counted.
     *
     * Generated from protobuf field <code>bool count_total_payments = 5;</code>
     * @return bool
     */
    public function getCountTotalPayments()
    {
        return $this->count_total_payments;
    }

    /**
     *If set, all payments (complete and incomplete, independent of the
     *max_payments parameter) will be counted. Note that setting this to true will
     *increase the run time of the call significantly on systems that have a lot
     *of payments, as all of them have to be iterated through to be counted.
     *
     * Generated from protobuf field <code>bool count_total_payments = 5;</code>
     * @param bool $var
     * @return $this
     */
    public function setCountTotalPayments($var)
    {
        GPBUtil::checkBool($var);
        $this->count_total_payments = $var;

        return $this;
    }

}

