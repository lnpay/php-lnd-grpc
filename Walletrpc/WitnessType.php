<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: walletkit.proto

namespace Walletrpc;

use UnexpectedValueException;

/**
 * Protobuf type <code>walletrpc.WitnessType</code>
 */
class WitnessType
{
    /**
     * Generated from protobuf enum <code>UNKNOWN_WITNESS = 0;</code>
     */
    const UNKNOWN_WITNESS = 0;
    /**
     *A witness that allows us to spend the output of a commitment transaction
     *after a relative lock-time lockout.
     *
     * Generated from protobuf enum <code>COMMITMENT_TIME_LOCK = 1;</code>
     */
    const COMMITMENT_TIME_LOCK = 1;
    /**
     *A witness that allows us to spend a settled no-delay output immediately on a
     *counterparty's commitment transaction.
     *
     * Generated from protobuf enum <code>COMMITMENT_NO_DELAY = 2;</code>
     */
    const COMMITMENT_NO_DELAY = 2;
    /**
     *A witness that allows us to sweep the settled output of a malicious
     *counterparty's who broadcasts a revoked commitment transaction.
     *
     * Generated from protobuf enum <code>COMMITMENT_REVOKE = 3;</code>
     */
    const COMMITMENT_REVOKE = 3;
    /**
     *A witness that allows us to sweep an HTLC which we offered to the remote
     *party in the case that they broadcast a revoked commitment state.
     *
     * Generated from protobuf enum <code>HTLC_OFFERED_REVOKE = 4;</code>
     */
    const HTLC_OFFERED_REVOKE = 4;
    /**
     *A witness that allows us to sweep an HTLC output sent to us in the case that
     *the remote party broadcasts a revoked commitment state.
     *
     * Generated from protobuf enum <code>HTLC_ACCEPTED_REVOKE = 5;</code>
     */
    const HTLC_ACCEPTED_REVOKE = 5;
    /**
     *A witness that allows us to sweep an HTLC output that we extended to a
     *party, but was never fulfilled.  This HTLC output isn't directly on the
     *commitment transaction, but is the result of a confirmed second-level HTLC
     *transaction. As a result, we can only spend this after a CSV delay.
     *
     * Generated from protobuf enum <code>HTLC_OFFERED_TIMEOUT_SECOND_LEVEL = 6;</code>
     */
    const HTLC_OFFERED_TIMEOUT_SECOND_LEVEL = 6;
    /**
     *A witness that allows us to sweep an HTLC output that was offered to us, and
     *for which we have a payment preimage. This HTLC output isn't directly on our
     *commitment transaction, but is the result of confirmed second-level HTLC
     *transaction. As a result, we can only spend this after a CSV delay.
     *
     * Generated from protobuf enum <code>HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL = 7;</code>
     */
    const HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL = 7;
    /**
     *A witness that allows us to sweep an HTLC that we offered to the remote
     *party which lies in the commitment transaction of the remote party. We can
     *spend this output after the absolute CLTV timeout of the HTLC as passed.
     *
     * Generated from protobuf enum <code>HTLC_OFFERED_REMOTE_TIMEOUT = 8;</code>
     */
    const HTLC_OFFERED_REMOTE_TIMEOUT = 8;
    /**
     *A witness that allows us to sweep an HTLC that was offered to us by the
     *remote party. We use this witness in the case that the remote party goes to
     *chain, and we know the pre-image to the HTLC. We can sweep this without any
     *additional timeout.
     *
     * Generated from protobuf enum <code>HTLC_ACCEPTED_REMOTE_SUCCESS = 9;</code>
     */
    const HTLC_ACCEPTED_REMOTE_SUCCESS = 9;
    /**
     *A witness that allows us to sweep an HTLC from the remote party's commitment
     *transaction in the case that the broadcast a revoked commitment, but then
     *also immediately attempt to go to the second level to claim the HTLC.
     *
     * Generated from protobuf enum <code>HTLC_SECOND_LEVEL_REVOKE = 10;</code>
     */
    const HTLC_SECOND_LEVEL_REVOKE = 10;
    /**
     *A witness type that allows us to spend a regular p2wkh output that's sent to
     *an output which is under complete control of the backing wallet.
     *
     * Generated from protobuf enum <code>WITNESS_KEY_HASH = 11;</code>
     */
    const WITNESS_KEY_HASH = 11;
    /**
     *A witness type that allows us to sweep an output that sends to a nested P2SH
     *script that pays to a key solely under our control.
     *
     * Generated from protobuf enum <code>NESTED_WITNESS_KEY_HASH = 12;</code>
     */
    const NESTED_WITNESS_KEY_HASH = 12;
    /**
     *A witness type that allows us to spend our anchor on the commitment
     *transaction.
     *
     * Generated from protobuf enum <code>COMMITMENT_ANCHOR = 13;</code>
     */
    const COMMITMENT_ANCHOR = 13;
    /**
     *A witness type that is similar to the COMMITMENT_NO_DELAY type,
     *but it omits the tweak that randomizes the key we need to
     *spend with a channel peer supplied set of randomness.
     *
     * Generated from protobuf enum <code>COMMITMENT_NO_DELAY_TWEAKLESS = 14;</code>
     */
    const COMMITMENT_NO_DELAY_TWEAKLESS = 14;
    /**
     *A witness type that allows us to spend our output on the counterparty's
     *commitment transaction after a confirmation.
     *
     * Generated from protobuf enum <code>COMMITMENT_TO_REMOTE_CONFIRMED = 15;</code>
     */
    const COMMITMENT_TO_REMOTE_CONFIRMED = 15;
    /**
     *A witness type that allows us to sweep an HTLC output that we extended
     *to a party, but was never fulfilled. This _is_ the HTLC output directly
     *on our commitment transaction, and the input to the second-level HTLC
     *timeout transaction. It can only be spent after CLTV expiry, and
     *commitment confirmation.
     *
     * Generated from protobuf enum <code>HTLC_OFFERED_TIMEOUT_SECOND_LEVEL_INPUT_CONFIRMED = 16;</code>
     */
    const HTLC_OFFERED_TIMEOUT_SECOND_LEVEL_INPUT_CONFIRMED = 16;
    /**
     *A witness type that allows us to sweep an HTLC output that was offered
     *to us, and for which we have a payment preimage. This _is_ the HTLC
     *output directly on our commitment transaction, and the input to the
     *second-level HTLC success transaction. It can only be spent after the
     *commitment has confirmed.
     *
     * Generated from protobuf enum <code>HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL_INPUT_CONFIRMED = 17;</code>
     */
    const HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL_INPUT_CONFIRMED = 17;
    /**
     *A witness type that allows us to spend our output on our local
     *commitment transaction after a relative and absolute lock-time lockout as
     *part of the script enforced lease commitment type.
     *
     * Generated from protobuf enum <code>LEASE_COMMITMENT_TIME_LOCK = 18;</code>
     */
    const LEASE_COMMITMENT_TIME_LOCK = 18;
    /**
     *A witness type that allows us to spend our output on the counterparty's
     *commitment transaction after a confirmation and absolute locktime as part
     *of the script enforced lease commitment type.
     *
     * Generated from protobuf enum <code>LEASE_COMMITMENT_TO_REMOTE_CONFIRMED = 19;</code>
     */
    const LEASE_COMMITMENT_TO_REMOTE_CONFIRMED = 19;
    /**
     *A witness type that allows us to sweep an HTLC output that we extended
     *to a party, but was never fulfilled. This HTLC output isn't directly on
     *the commitment transaction, but is the result of a confirmed second-level
     *HTLC transaction. As a result, we can only spend this after a CSV delay
     *and CLTV locktime as part of the script enforced lease commitment type.
     *
     * Generated from protobuf enum <code>LEASE_HTLC_OFFERED_TIMEOUT_SECOND_LEVEL = 20;</code>
     */
    const LEASE_HTLC_OFFERED_TIMEOUT_SECOND_LEVEL = 20;
    /**
     *A witness type that allows us to sweep an HTLC output that was offered
     *to us, and for which we have a payment preimage. This HTLC output isn't
     *directly on our commitment transaction, but is the result of confirmed
     *second-level HTLC transaction. As a result, we can only spend this after
     *a CSV delay and CLTV locktime as part of the script enforced lease
     *commitment type.
     *
     * Generated from protobuf enum <code>LEASE_HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL = 21;</code>
     */
    const LEASE_HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL = 21;
    /**
     *A witness type that allows us to spend a regular p2tr output that's sent
     *to an output which is under complete control of the backing wallet.
     *
     * Generated from protobuf enum <code>TAPROOT_PUB_KEY_SPEND = 22;</code>
     */
    const TAPROOT_PUB_KEY_SPEND = 22;

    private static $valueToName = [
        self::UNKNOWN_WITNESS => 'UNKNOWN_WITNESS',
        self::COMMITMENT_TIME_LOCK => 'COMMITMENT_TIME_LOCK',
        self::COMMITMENT_NO_DELAY => 'COMMITMENT_NO_DELAY',
        self::COMMITMENT_REVOKE => 'COMMITMENT_REVOKE',
        self::HTLC_OFFERED_REVOKE => 'HTLC_OFFERED_REVOKE',
        self::HTLC_ACCEPTED_REVOKE => 'HTLC_ACCEPTED_REVOKE',
        self::HTLC_OFFERED_TIMEOUT_SECOND_LEVEL => 'HTLC_OFFERED_TIMEOUT_SECOND_LEVEL',
        self::HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL => 'HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL',
        self::HTLC_OFFERED_REMOTE_TIMEOUT => 'HTLC_OFFERED_REMOTE_TIMEOUT',
        self::HTLC_ACCEPTED_REMOTE_SUCCESS => 'HTLC_ACCEPTED_REMOTE_SUCCESS',
        self::HTLC_SECOND_LEVEL_REVOKE => 'HTLC_SECOND_LEVEL_REVOKE',
        self::WITNESS_KEY_HASH => 'WITNESS_KEY_HASH',
        self::NESTED_WITNESS_KEY_HASH => 'NESTED_WITNESS_KEY_HASH',
        self::COMMITMENT_ANCHOR => 'COMMITMENT_ANCHOR',
        self::COMMITMENT_NO_DELAY_TWEAKLESS => 'COMMITMENT_NO_DELAY_TWEAKLESS',
        self::COMMITMENT_TO_REMOTE_CONFIRMED => 'COMMITMENT_TO_REMOTE_CONFIRMED',
        self::HTLC_OFFERED_TIMEOUT_SECOND_LEVEL_INPUT_CONFIRMED => 'HTLC_OFFERED_TIMEOUT_SECOND_LEVEL_INPUT_CONFIRMED',
        self::HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL_INPUT_CONFIRMED => 'HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL_INPUT_CONFIRMED',
        self::LEASE_COMMITMENT_TIME_LOCK => 'LEASE_COMMITMENT_TIME_LOCK',
        self::LEASE_COMMITMENT_TO_REMOTE_CONFIRMED => 'LEASE_COMMITMENT_TO_REMOTE_CONFIRMED',
        self::LEASE_HTLC_OFFERED_TIMEOUT_SECOND_LEVEL => 'LEASE_HTLC_OFFERED_TIMEOUT_SECOND_LEVEL',
        self::LEASE_HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL => 'LEASE_HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL',
        self::TAPROOT_PUB_KEY_SPEND => 'TAPROOT_PUB_KEY_SPEND',
    ];

    public static function name($value)
    {
        if (!isset(self::$valueToName[$value])) {
            throw new UnexpectedValueException(sprintf(
                    'Enum %s has no name defined for value %s', __CLASS__, $value));
        }
        return self::$valueToName[$value];
    }


    public static function value($name)
    {
        $const = __CLASS__ . '::' . strtoupper($name);
        if (!defined($const)) {
            throw new UnexpectedValueException(sprintf(
                    'Enum %s has no value defined for name %s', __CLASS__, $name));
        }
        return constant($const);
    }
}

